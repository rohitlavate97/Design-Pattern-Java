Design Pattern:
--------------
-Selection of Design pattern
-Solution to Design problem using Design pattern

Types of Design Pattern:
-----------------------
--Creational Patterns: Singleton
                       AbstractFactory
					   Builder
					   Factory Method
					   Prototype
--Structural Patterns: Adapter
                       Bridge
					   Composite
					   Decorator
					   Facade
					   Flyweight
					   Proxy
--Behavioral Patterns: Chain of Responsibility
                       Command
					   Interpreter
					   Iterator
					   Mediator
					   Memento
					   Observer
					   State
					   Strategy
					   Template method
					   
-MicroServices Design Pattern--> API Gateway
                                 Saga Pattern
								 Database per Service
								 Distribute tracing
								 Circuit Breaker
								 Service Discovery pattern
								 
-SOLID Design Principle Overview
--------------------------------
S --> Single Responsibility
O --> Open Closed Principle  --> Open for extension, closed for modification 
L --> Liskov substitution
I --> Interface Segregation
D --> Dependency Injection
--------------------------
--1)Singleton Design Pattern:
--------------------------
Create a Java Project--> Name-->01-SingleTonDP
                         JRE--->JavaSE-1.8
						 
--'new' keyword makes sure that it creates new object so hashcode is different
--Singleton can be created in 
     1. Eager Initialization Singleton: Since object is static variable in SingletonDesignPattern class, it initialized during class loading, it is not even waiting to call
	                                    the getInstance() -->Object created at class loading time itself, whether you are using or not, it occupy memory
										this is EAGER initialization
	 2. Lazy Initialization Singleton
	    public class SingletonDesignPattern {

        private static SingletonDesignPattern instance;

        private SingletonDesignPattern() {
        }

        public static SingletonDesignPattern getInstance() {
          if (instance == null) {
             instance = new SingletonDesignPattern();
          }
          return instance;
        }
     }

	 3. Thread-Safe Singleton using synchronized
	  public static synchronized SingletonDesignPattern getInstance() {
        if (instance == null) {                                         //if we directly return new SingletonDesignPattern(); --> it will create new object everytime, so violation
            instance = new SingletonDesignPattern();
        }
        return instance;
    }
	
	 4. Bill Pugh Singleton (Recommended)
	 
public class SingletonDesignPattern {             //‚úÖ The Bill Pugh method is widely considered the best practice for Singleton in Java. 

    private SingletonDesignPattern() {
    }

    // Inner static helper class
    private static class SingletonHelper {
        private static final SingletonDesignPattern INSTANCE = new SingletonDesignPattern();
    }

    public static SingletonDesignPattern getInstance() {
        return SingletonHelper.INSTANCE;
    }
}

--Where we can use Singleton--->DB Connection ---> DBConnection.getInstance();
                            --->If we want the data from properties file-->getProperties.getInstance();   //getInstance() means, we are creating singleton class
							--->For providing utility-->e.g To notify i.e notification after delivery,shipping, cancellation order etc
							--->For logger
			In Java------------>Runtime class follows singleton design pattern-->java.lang
			                    Runtime r = new Runtime();   //error as Runtime() is private constructor
								Runtime r = Runtime.getInstance()   //Works
                        ------->Calender class
						
WHY Singleton for Notification / Email / SMS Services?
‚úÖ 1. These services do NOT maintain any user-specific state
A notification service is stateless.
Example: Every time you call sendEmail(), it just sends mail.
It doesn't store user data inside the object.
So, one object is enough ‚Üí Why create many?
‚úÖ 2. External resources (SMTP, SMS gateway, notification API) must be reused
Example:When sending emails, you usually connect to:
      SMTP server
      REST API client
      Third-party gateway
Opening multiple connections is expensive.
Using Singleton means:
      One SMTP connection reused
      One HTTP client reused
      Zero repeated heavy initialization
						
‚≠ê WHY this is good?
1Ô∏è‚É£ Only one object is created
Avoids multiple objects doing same thing.
2Ô∏è‚É£ Heavy resources (SMTP client, HTTP client) are created only once
Better performance.
3Ô∏è‚É£ All notifications pass through the same service
Makes logging, retry logic, and monitoring easier.
4Ô∏è‚É£ Reduces bugs
No duplication of configuration or connection issues.
						
Note: Serialization belongs to Object. Static value is not serialized, even if you modify the value whatever is their at loading time that will be displayed

App:
----
public class SingletonDesignPattern {

    // instance is created at the time of class loading
    static SingletonDesignPattern instance = new SingletonDesignPattern();

    // private constructor to prevent instantiation
    private SingletonDesignPattern() {
    }

    // public method to provide access to the instance
    public static SingletonDesignPattern getInstance() {
        return instance;                        //from static method only static variable can be accessed
    }

    // example method
    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}


public class Test {
	public static void main(String[] args) {
		NonSingleton ns1 = new NonSingleton();
		NonSingleton ns2 = new NonSingleton();
		System.out.println(ns1.hashCode());
		System.out.println(ns2.hashCode());
		
		SingletonDesignPattern s1 = SingletonDesignPattern.getInstance();
		SingletonDesignPattern s2 = SingletonDesignPattern.getInstance();
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}
}


-We can violate the Singleton with some mechanism
   Reflection --> We can call private constructor
   Cloning
   Serialization
   Multi-threading
   
   
--Serialization:
----------------
public class Singleton implements Serializable{
	static Singleton instance = null;
	
	String name = "karthik";
	
	private Singleton() {
		
	}
	
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}


public class TestForSerialization {
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		//Serialization
		String filePath = "C:\\data\\Projects\\Design Pattern\\serializableDoc.txt";
		Singleton s = Singleton.getInstance();
		
		FileOutputStream f = new FileOutputStream(filePath);
		ObjectOutputStream obj = new ObjectOutputStream(f);
		obj.writeObject(s);
		//Deserialization
		FileInputStream fi = new FileInputStream(filePath);
		ObjectInputStream in = new ObjectInputStream(fi);
		Singleton s1 = (Singleton)in.readObject();
		System.out.println(s1.name);              //karthik
		System.out.println(s1.hashCode());        //2058534881
		
		System.out.println(s.hashCode());         //1267032364
	}
}

--So using serialization, we can create multiple object for Singleton design pattern class ie breaking Singleton pattern
Solution : Whenever readObject() getting called --> internally it calls readResolve(), which is responsible for creating new object, so we will override readResolve()
--------
public class Singleton implements Serializable{
	static Singleton instance = null;
	
	String name = "karthik";
	
	private Singleton() {
		
	}
	
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
	Object readResolve(){
		return instance;
	}
}
now check the hashcode


--MultiTheading: Thread is nothing but independent path of execution within a program
---------------
public class TestForMultiThreads extends Thread {

    @Override
    public void run() {
        Singleton s = Singleton.getInstance();
        System.out.println(Thread.currentThread().getName() 
                + " => " + s.hashCode());
    }

    public static void main(String[] args) {
        TestForMultiThreads t1 = new TestForMultiThreads();
        TestForMultiThreads t2 = new TestForMultiThreads();

        t1.setName("Thread_1");
        t2.setName("Thread_2");

        t1.start();                    //In both cases (s==null) satisfies, so both will access to new object
        t2.start();
    }
}

Solution:
---------
 public static synchronized SingletonDesignPattern getInstance() {
        if (instance == null) {                                         
            instance = new SingletonDesignPattern();
        }
        return instance;  
    }
	--> After using synchronized method, it will acquire the lock(Class lock the static method)
	    If we try with Thread2---> It will go into stepping mode, ie waiting for loc to be released
		Once the thread1 access Synchronized method lock released and Thread2 will access it and value of s is not null
		
-If we have 100's of line of code, we can use synchronized block also
  
public class Singleton {
    private static volatile Singleton s;  // volatile is important
    private Singleton() {}
    public static Singleton getInstance() {
        System.out.println("hi");
        System.out.println("hi");
        System.out.println("hi");
        if (s == null) {
            synchronized (Singleton.class) {
                if (s == null) {
                    s = new Singleton();
                }
            }
        }
        return s;
    }
}

--Reflection: Private Constructor can be called using Reflection
------------
-From java.lang.Class 
getDeclaredConstructor() --->Can access private constructor
getDeclaredFields()      --->can access private fields
getDeclaredMethods()     --->can access private methods
eg-->Class<T>.getDeclaredConstructor()



| Method Type                  | `getDeclaredXxx()`                       | `getXxx()`                                                |
| ---------------------------- | ---------------------------------------- | --------------------------------------------------------- |
| Functions                    | Returns **all members inside the class** | Returns **only public members**, including inherited ones |
| Shows private?               | ‚úî Yes                                    | ‚ùå No                                                      |
| Includes superclass members? | ‚ùå No                                     | ‚úî Yes (public only)                                       |

public class TestForReflection {
	public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		Singleton s1 = Singleton.getInstance();
		System.out.println(s1.hashCode());                                                       //1159190947
		
		Constructor<Singleton> declaredConstructor = Singleton.class.getDeclaredConstructor();
		declaredConstructor.setAccessible(true);
		Singleton s2 = declaredConstructor.newInstance();
		System.out.println(s2.hashCode());                                                      //1421795058
	}
}

--Solution:
public class Singleton {

    private static Singleton instance;
    private static boolean instanceCreated = false;

    private Singleton() {
        if (instanceCreated) {
            throw new RuntimeException("Reflection is not allowed!");          //Throwing exception as we can't return anything from constructor
        }
        instanceCreated = true;
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

same code can be written as 

private Singleton{
   if(s!=null){                                                  //When already object present, then and we trying to access constructor with Reflection-->Exception
    throw new Exception();
	}
}

--Cloning -->
---------
If you want your Singleton to be 100% safe, you must also protect it from Cloning ‚Äî because cloning can also break Singleton just like Reflection.
If your Singleton implements Cloneable, cloning creates a new object, breaking the rule of ‚Äúonly one instance‚Äù.
Example:

Singleton s1 = Singleton.getInstance();
Singleton s2 = (Singleton) s1.clone();               //Different object, different memory-->If we change values for object, it will not reflect in cloned object
System.out.println(s1 == s2); // false ‚ùó (Singleton broken)

-Shallow cloning--> If you modify original object, cloned object will have modified object.
-Deep Cloning--> If you modify original object, when we have object reference, it will not reflect in cloned object ie it will use seperate memory.
                 For this,we have to override in the clone()

| Feature          | Shallow Cloning                 | Deep Cloning                        |
| ---------------- | ------------------------------- | ----------------------------------- |
| Primitive fields | Copied                          | Copied                              |
| Object fields    | Same reference (shared)         | New independent object              |
| Speed            | Faster                          | Slower                              |
| When to use      | Immutable or simple objects     | Complex objects with nested objects |
| Risk             | Side effects due shared objects | Safe, no shared state               |

üß† Interview Tip

Java‚Äôs default clone (super.clone()) always performs SHALLOW COPY.
If you want deep copy, you must manually clone nested objects.


public class Singleton implements Cloneable {
	static Singleton instance = null;

	private Singleton() {

	}

	public static Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}

	
	  @Override 
	  protected Object clone() { //method present in object class, so if we directly call in test class it is protected //actually it returns super.clone(); 
	         return instance;   //return same object
	  }
	 
}


public class TestForCloning {
	public static void main(String[] args) {
		Singleton s1 = Singleton.getInstance();
		System.out.println(s1.hashCode());
		
        Singleton s2 = (Singleton)s1.clone();
		System.out.println(s2.hashCode());
	}
	
}

--Runtime runtime = Runtime.getRuntime();
System.out.println(runtime.freeMemory());
üß† Interview Note
Yes, Runtime is an example of a Singleton design pattern, but Java exposes the instance using:
üëâ getRuntime()
--Runtime doesn't impement Serializable,Clonable

--java.util.logging.Logger.getLogger() is slow?. Logger.getLogger() is slower compared to normal object creation because internally it does MANY things:

--Double-Checked Locking Singleton
public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {

        if (instance == null) {                     // 1st check (no locking)
            synchronized (Singleton.class) {        // lock
                if (instance == null) {             // 2nd check (inside lock)
                    instance = new Singleton();     // create object
                }
            }
        }

        return instance;   // return same instance always
    }
}
üß† Why DOUBLE check?
‚úî First check
Prevents unnecessary synchronization.
Most calls will skip the lock.
‚úî Second check
Prevents multiple threads from creating multiple instances at the same time.

-------------------------
-2)Factory Design Pattern:
-------------------------
-1. ‚ÄúWhenever you want to work with constructor, go for abstract class.‚Äù
‚úîÔ∏è TRUE ‚Äî but incomplete.
Interfaces cannot have constructors
(because they cannot have instance fields)
Abstract classes can have constructors
and those constructors run when a subclass object is created.
üëâ Use an abstract class when:
You need a constructor
You need non-final fields
You need to maintain state
You want to provide common methods, partial implementation, template patterns
You want non-static variables or methods

-2. ‚ÄúWhen you want static final values, go for interface.‚Äù
‚úîÔ∏è TRUE ‚Äî but outdated in wording.
All fields inside an interface are public static final by default (constants).
Interfaces are best for constants and behavior contracts.
üëâ Use an interface when:
You want constants
You want only method signatures + (Java 8+) default/static methods
You want multiple inheritance of type

| Feature              | Interface                  | Abstract Class                             |
| -------------------- | -------------------------- | ------------------------------------------ |
| Constructor          | ‚ùå No                       | ‚úî Yes                                    |
| Variables            | Only `public static final` | Any type (`private`, `protected`, mutable)  | 
| Multiple Inheritance | ‚úî Yes                      | ‚ùå No                                       |
| Default Methods      | ‚úî Yes (Java 8)             | ‚úî Yes                                      |
| Static Methods       | ‚úî Yes                      | ‚úî Yes                                      |
| State                | ‚ùå No                       | ‚úî Yes                                      |

--The Factory design pattern says that, define an interface (A Java Interface or an abstract class) and let the subclass decide which object to instantiate. The Factory method in the interface
lets a class define the instantiation to one or more subclass.
 -In Factory pattern, we create objects without exposing the creation logic to the client and the client uses the same common interface to create a new type of object.
 -In factory pattern, we create object withour exposing the creation logic to the client and refer to newly created object using common interface.
 -A factory pattern or factory method pattern says that just define an interface or abstract class for creating an object but, let the subclasss decide to instantiate
 -The factory method pattern is also known as virtual constructor.
 --Real Time use
 ---------------
          -getInstance() of java.util.Calender.NumberFormat and ResourceBundle uses factory method design pattern
		  -Consider and example of using multiple database servers like SQL server and Oracle, if you developing an app using SQL Server db as backend but, in future need to change backend db to oracle,
		  you will need to modify all your code, if you haven't written your code following factory design pattern
		  -In factory design pattern, you need to do very littele work to achieve this. A class implementing factory design pattern takes care for you and lessen your burden. Switching from db server won't 
		  bother you at all. You just need to make some small changes in your configuration file or db connection based on the type of db, then in future there is no need to modify the change whenever db is 
		  switched
		  
App:
----
package com.alchemist.dp;

public interface Notification {
	public void notifi();
}


public class SMSNotification implements Notification{

	@Override
	public void notifi() {
		System.out.println("Triggering notification through SMS...");
	}

}


public class EmailNotification implements Notification{

	@Override
	public void notifi() {
		System.out.println("Triggering notification through email...");
		
	}

}


public class Factory {
	public Notification createNotification(String mode) {
		if(mode.equalsIgnoreCase("sms")) {
			Notification n = new SMSNotification();
			return n;
		}
		if(mode.equalsIgnoreCase("email")) {
			Notification n = new EmailNotification();
		}
		return null;
	}
}


public class FactoryDesignPatternMainClass {
	public static void main(String[] args) {
		Factory f = new Factory();
		Notification n = f.createNotification("sms");
		n.notifi();
	}
}

----------------------------
--3)Chain of Responsibility  : JVM by default follows this design pattern
----------------------------
Sender 
   ‚îÇ
   ‚ñº
+-----------+     +-----------+     +-----------+     +-----------+
| Handler 1 | ‚îÄ‚îÄ‚îÄ‚ñ∫| Handler 2 | ‚îÄ‚îÄ‚îÄ‚ñ∫| Handler 3 | ‚îÄ‚îÄ‚îÄ‚ñ∫| Handler 4 |
+-----------+     +-----------+     +-----------+     +-----------+
      ‚îÇ                 ‚îÇ                 ‚îÇ                 ‚îÇ
      ‚îú‚îÄ‚îÄ handles? ‚áí YES‚îÇ                 ‚îÇ                 ‚îÇ
      ‚îÇ                 ‚îú‚îÄ‚îÄ handles? ‚áí YES‚îÇ                 ‚îÇ
      ‚îÇ                 ‚îÇ                 ‚îú‚îÄ‚îÄ handles? ‚áí YES‚îÇ
      ‚îÇ                 ‚îÇ                 ‚îÇ                 ‚îú‚îÄ‚îÄ handles? ‚áí YES
      ‚ñº                 ‚ñº                 ‚ñº                 ‚ñº
 Receiver          Receiver          Receiver          Receiver

-Chain of Responsibility is a design pattern consisting of a source of command objects and a series of processing objects.
-Chain of Responsibility is a behavioral design pattern where a request (command) is sent from a source and travels through a chain of processing objects, where each object can handle the request or pass it to the next one.
-The Chain of Responsibility is a behavioral design pattern that lets you pass a request along a chain of handlers.Each handler decides either to process the request or pass it to the next handler in the chain.
There is a source of the request (client).
-There is a chain of handlers (processing objects).
Each handler either:
‚úî processes the request
‚úî OR passes it forward
This removes tight coupling between sender and receiver.
--How JVM will handle Exception:--> 
  class ChainOfResponsibility{
    main(){
	 m1();
	 }
	 static void m1(){
	 m2();
	 }
	 static void m2(){
	 m3();
	 }
	 static void m3(){
	  int c = 10/0;
	  }
   }
      --Once an exception occurs in m3(), the JVM creates an ArithmeticException object.JVM checks if m3() handles the exception. If not, it checks the caller m2().
        If still not handled, it checks m1(), then main().If nobody handles it, the JVM‚Äôs default exception handler prints the stack trace and terminates the program.
		
Stack Trace (Bottom ‚Üí Top of stack):
main()  ‚óÑ‚îÄ‚îÄ m1() ‚óÑ‚îÄ‚îÄ m2() ‚óÑ‚îÄ‚îÄ m3()  ‚óÑ‚îÄ‚îÄ Exception created here

What problem this design pattern solves:-->
            -Coupling the sender of request to its receiver should be avoided
			-It should be possible that more than one receiver can handle the request
			-In Java world, we benefit from chain of Responsibility every day, one classic example is Servelet Filters in Java that allows multiple filters to process an HTTP Request. Though in that case, each flter
			invoke the chain instead of the next filter.
			  public class CustomFilter(ServeletRequest request, ServeletResponse response,Filterchain chain) throws IoException, ServeletException{
			       //Process the request
				   //Pass the request(i.e command) along the fileter chain
				   chain.doFilter(request,response);
				 }
				}
			-If credentials are correct, transfer request to corresponding controller. We can have multiple filters, once first filter executed successfully, we can add another(Request from one filter
			comes to other filter, ex-->Bank customer and Employee)
			-Multiple filters form a chain. If each filter validates successfully, the request moves to the next filter. When all filters approve, the request is finally routed to the correct controller.
Client Request
      ‚îÇ
      ‚ñº
+----------------+     +----------------+     +----------------+     +-----------------+
| Auth Filter    | ‚îÄ‚îÄ‚îÄ‚ñ∫| Role Filter    | ‚îÄ‚îÄ‚îÄ‚ñ∫| Routing Filter | ‚îÄ‚îÄ‚îÄ‚ñ∫|  Controller     |             =====>Chaining(Delegation) ie Request sent from one object to other
| (Check login)  |     | (Emp/Customer) |     | (Find correct  |     |  (Final target) |
+----------------+     +----------------+     |  controller)   |     +-----------------+
      ‚îÇ                  ‚îÇ                      +----------------+
      ‚îÇ                  ‚îÇ
      ‚îÇ                  ‚îî‚îÄ‚îÄ passes request if role matches
      ‚îÇ
      ‚îî‚îÄ‚îÄ passes request only if credentials are valid

Real-World Examples
--Example 1: Logging System
DEBUG log handled by DebugLogger
INFO log handled by InfoLogger
ERROR log handled by ErrorLogger
--Example 2: ATM Withdrawal
2000 rupee handler
500 rupee handler
100 rupee handler
Each handler processes what it can and passes the remainder.
--Example 3: Leave Approval System
Team Lead ‚Üí Manager ‚Üí Director
Only the handler with authority approves.

App:
---
package com.alchemist.dp;

public class Currency {
	private Integer amount;
	
	Currency(Integer amount){
		this.amount = amount;
	}

	public Integer getAmount() {
		return amount;
	}

	public void setAmount(Integer amount) {
		this.amount = amount;
	}
	
}

package com.alchemist.dp;

public interface DispenseChain {
	void dispence(Currency currency);
	void chain(DispenseChain d);
}


package com.alchemist.dp;

public class Notes2000Rack implements DispenseChain {

    private DispenseChain chain;

    @Override
    public void dispence(Currency currency) {
        Integer noOf2000Notes = currency.getAmount() / 2000;
        System.out.println("Dispatching: " + noOf2000Notes + " 2000 notes");
        
        Integer remainder = currency.getAmount() % 2000;

        if (remainder != 0) {
            this.chain.dispence(new Currency(remainder));
        }
    }

    @Override
    public void chain(DispenseChain d) {
        this.chain = d;   // FIXED
    }
}
//same for 500 and 100


package com.alchemist.dp;

import java.util.Scanner;

public class ChainOfResponsibilityMainClass {

    private DispenseChain chain;

    public ChainOfResponsibilityMainClass() {
        this.chain = new Notes2000Rack();
        DispenseChain c500 = new Notes500Rack();
        DispenseChain c100 = new Notes100Rack();

        chain.chain(c500);
        c500.chain(c100);
    }

    public static void main(String[] args) {

        ChainOfResponsibilityMainClass atm = new ChainOfResponsibilityMainClass();
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println("Enter amount to withdraw (0 to exit):");

            int amount = sc.nextInt();
            if (amount == 0) {
                System.out.println("Thank you! Exiting...");
                break;
            }

            if (amount % 100 != 0) {
                System.out.println("Amount must be multiple of 100.");
                continue;
            }

            atm.chain.dispence(new Currency(amount));
            System.out.println("------------------------------------");
        }

        sc.close();
    }
}
--------------------------------
package com.alchemist.dp;

public abstract class Handler {
	protected Handler next;

	public Handler setNext(Handler next) {
		this.next = next;
		return next;
	}

	public abstract void handleRequest(String request);
}


package com.alchemist.dp;

class HandlerA extends Handler {
    @Override
    public void handleRequest(String request) {
        if (request.equals("A")) {
            System.out.println("Handler A processed the request");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}


package com.alchemist.dp;

class HandlerB extends Handler {
    @Override
    public void handleRequest(String request) {
        if (request.equals("B")) {
            System.out.println("Handler B processed the request");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

package com.alchemist.dp;

public abstract class LeaveHandler {
    protected LeaveHandler next;
 
    public void setNext(LeaveHandler next) {
        this.next = next;
    }
 
    public abstract void approveLeave(int days);
}
 
class TeamLead extends LeaveHandler {
    @Override
    public void approveLeave(int days) {
        if (days <= 2) {
            System.out.println("Team Lead approved leave");
        } else if (next != null) {
            next.approveLeave(days);
        }
    }
}
 
class Manager extends LeaveHandler {
    @Override
    public void approveLeave(int days) {
        if (days <= 5) {
            System.out.println("Manager approved leave");
        } else if (next != null) {
            next.approveLeave(days);
        }
    }
}
 
class Director extends LeaveHandler {
    @Override
    public void approveLeave(int days) {
        if (days <= 10) {
            System.out.println("Director approved leave");
        } else {
            System.out.println("Leave too long ‚Äî rejected");
        }
    }
}

package com.alchemist.dp;

public class Application {
    public static void main(String[] args) {
        LeaveHandler tl = new TeamLead();
        LeaveHandler mgr = new Manager();
        LeaveHandler dir = new Director();
 
        tl.setNext(mgr);
        mgr.setNext(dir);
 
        tl.approveLeave(7);
    }
}

package com.alchemist.dp;

public class Client {
    public static void main(String[] args) {
        HandlerA h1 = new HandlerA();
        HandlerB h2 = new HandlerB();
 
        h1.setNext(h2);
 
        h1.handleRequest("B");
    }
}
--------------------------------------
